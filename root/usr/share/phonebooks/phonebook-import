#!/usr/bin/env python2
import os, glob, sys, json, signal, logging, MySQLdb, argparse, datetime
LOG_PATH = '/var/log/phonebook-import.log'
DEST_PATH = '/etc/phonebook/destination-import.json'

def signalHandler(sig, frame):
  logger.critical('interrupted by SIGINT')
  sys.exit(0)

signal.signal(signal.SIGINT, signalHandler)

def getDbConn(config):
  if config['dbtype'] == 'mysql':
    port = unixSocket = None
    try:
      port = int(config['port'])
    except:
      port = None
      unixSocket = config['port']
    try:
      if port:
        return MySQLdb.connect(host=config['host'], port=port, user=config['user'], passwd=config['password'], db=config['dbname'])
      else:
        return MySQLdb.connect(host=config['host'], unix_socket=unixSocket, user=config['user'], passwd=config['password'], db=config['dbname'])
    except Exception as err:
      logger.error(str(err))
      return None

def syncSource(path, output, deleteonly):
  logger.info('start ' + ('check of' if output == True else '') + ' source import of ' + path + ' into phonebook.phonebook')
  try:
    logger.info('reading ' + path)
    with open(path, 'r') as sourceFile:
      sConfig = json.load(sourceFile)
  except Exception as err:
    logger.error('reading ' + path)
    logger.error(str(err))
    sys.exit(1)
  sid = next(iter(sConfig))
  logger.info(path + ' has "' + sid + '" source')
  dbSource = getDbConn(sConfig[sid])
  if dbSource != None:
    logger.info('source "' + sid + '" connection (' + sConfig[sid]['dbname'] + '): ok')
  else:
    logger.error('source "' + sid + '" connection (' + sConfig[sid]['dbname'] + '): failed')
    sys.exit(1)
  curSource = dbSource.cursor()
  if output == True:
    curSource.execute(sConfig[sid]['query'])
    rows = curSource.fetchall()
    cols = tuple([i[0] for i in curSource.description])
    res = []
    for row in rows:
      temp = {}
      for i, el in enumerate(row):
        temp[cols[i]] = el
      res.append(temp)
    if len(res) == 0:
      temp = {}
      for x in cols:
        temp[x] = ''
      res.append(temp)
    sys.stdout.write(json.dumps(res) + '\n')
    logger.info('write ' + str(len(rows)) + ' entries to std output')
    logger.info('end ' + ('check of' if output == True else '') + ' source import of ' + path + ' into phonebook.phonebook')
    curSource.close()
    dbSource.close()
    return
  try:
    with open(DEST_PATH, 'r') as configFile:
      dConfig = json.load(configFile)
  except Exception as err:
    logger.error('reading ' + DEST_PATH)
    logger.error(str(err))
    sys.exit(1)
  dbDest = getDbConn(dConfig)
  if dbDest != None:
    logger.info('destination db connection ("phonebook"): ok')
  else:
    logger.error('destination db connection ("phonebook"): failed')
    sys.exit(1)
  curDest = dbDest.cursor()
  try:
    delcount = curDest.execute('DELETE FROM ' + dConfig['dbtable'] + ' WHERE sid_imported="{}"'.format(sid))
    logger.info('clean destination: removed ' + str(delcount) + ' entries from ' + dConfig['dbname'] + '.' + dConfig['dbtable'] + ' with sid_imported="' + sid + '"')
    if deleteonly == True:
      return
  except Exception as err:
    logger.error('cleaning destination: removing entries from ' + dConfig['dbname'] + '.' + dConfig['dbtable'] + ' with sid_imported="' + sid + '"')
    logger.error(str(err))
  curSource.execute(sConfig[sid]['query'])
  toTransfer = curSource.rowcount
  logger.info('synchronizing source "' + sid + '" (' + str(toTransfer) + ' entries)...')
  start = datetime.datetime.now().replace(microsecond=0)
  destCols = sConfig[sid]['mapping'].values()
  destCols.append('sid_imported')
  curSource = dbSource.cursor(MySQLdb.cursors.SSCursor)
  curSource.execute(sConfig[sid]['query'])
  row = curSource.fetchone()
  importedCount = 0
  errCount = 0
  if sConfig[sid]['type'] != None:
    destCols.append('type')
  while row is not None:
    row = row + (str(sid), str(sConfig[sid]['type']))
    sql = 'INSERT INTO ' + dConfig['dbtable'] + ' (' + ','.join(destCols) + ') VALUES {}'.format(row)
    try:
      curDest.execute(sql)
      importedCount += 1
    except Exception as err:
      errCount += 1
      logger.error('copying entry "' + str(row) + '"')
      logger.error(str(err))
    dbDest.commit()
    row = curSource.fetchone()
  end = datetime.datetime.now().replace(microsecond=0)
  percent = str(importedCount*100/toTransfer) if toTransfer > 0 else '0'
  logger.info('source "' + sid + '" imported ' + percent + '%: ' + str(importedCount) + ' imported - ' + str(errCount) + ' errors - ' + str(toTransfer) + ' tot - duration ' + str(end-start))
  curSource.close()
  curDest.close()
  dbSource.close()
  dbDest.close()
  logger.info('end source import of ' + path + ' into phonebook.phonebook')

def extractArgsDbParams(data):
  result = {}
  for arg in data:
    result[arg.split('=')[0]] = arg.split('=')[1]
  return result

if __name__ == '__main__':
  descr = 'MySQL Phonebook importer. Imports contacts from a MySQL database source into phonebook.phonebook database. The destination configuration data is into the /etc/phonebook/destination-import.json file. The source configuration file path has to be declared using \"config\" option. The log file is ' + LOG_PATH + '.'
  parser = argparse.ArgumentParser(description=descr)
  parser.add_argument('source_path', help='absolute path of the source json configuration file')
  parser.add_argument('-lw', '--log_warning', action='store_true', help='enable only warning log messages in ' + LOG_PATH)
  parser.add_argument('-v', '--verbose', action='store_true', help='enable console debug')
  parser.add_argument('-c', '--check', action='store_true', help='it causes the writing of query results to standard output in JSON format instead of executing the database synchronization. Has more priority than deleteonly')
  parser.add_argument('-d', '--deleteonly', action='store_true', help='just delete entries from this configuration')
  args = parser.parse_args()
  logger = logging.getLogger(__name__)
  logger.setLevel(logging.INFO)
  cHandler = logging.StreamHandler()
  fHandler = logging.FileHandler(LOG_PATH)
  cHandler.setLevel(logging.INFO if args.verbose == True else logging.NOTSET)
  fHandler.setLevel(logging.INFO if args.log_warning == False else logging.WARNING)
  logFormat = logging.Formatter('%(asctime)s [%(process)s] %(levelname)s: %(message)s', datefmt='%d-%b-%y %H:%M:%S')
  cHandler.setFormatter(logFormat)
  fHandler.setFormatter(logFormat)
  if args.verbose == True:
    logger.addHandler(cHandler)
  logger.addHandler(fHandler)
  if args.source_path:
    syncSource(args.source_path, args.check, args.deleteonly)
  else:
    parser.print_help()
